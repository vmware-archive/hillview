
    JdbcConnectionInformation getInfo() {
        JdbcConnectionInformation conn = new JdbcConnectionInformation();
        conn.databaseKind = "impala";
        conn.host = "sql.vac.vmware.com";
        conn.port = 25003;
        conn.database = "history";
        conn.table = "airwatch_console";
        conn.user = "mbudiu";
        conn.password = "Vmqu33n``";
        return conn;
    }

    // Downloads an impala table and splits it into pieces.
    @Test
    public void downloadSplitTable() {
        int fragmentSize = 300000;
        JdbcConnectionInformation conn = this.getInfo();
        JdbcDatabase db = new JdbcDatabase(conn);
        try {
            db.connect();
            ResultSet dbTable = db.getTable(Converters.checkNull(conn.table), -1);
            Observer<ITable> obs = new Observer<ITable>() {
                int index = 0;

                @Override
                public void onCompleted() {}

                @Override
                public void onError(Throwable throwable) {
                    throwable.printStackTrace();
                }

                @Override
                public void onNext(ITable tbl) {
                    System.out.println("Received table " + index);
                    String file = conn.table + index;
                    if (index == 0)
                        tbl.getSchema().writeToJsonFile(Paths.get(conn.table + ".schema"));
                    CsvFileWriter fw = new CsvFileWriter(file + ".csv");
                    fw.setCompress(true);
                    try {
                        fw.writeTable(tbl);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    index++;
                }
            };
            JdbcDatabase.getTables(dbTable, fragmentSize, obs);
            db.disconnect();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    String sqlTime(Instant instant) {
        return "cast('" + instant.toString() + "' as timestamp)";
    }

    // Downloads an impala table and splits it into pieces by time intervals.
    //@Test
    public void downloadSplitTableByTime() throws SQLException {
        int fragmentSize = 300000;
        JdbcConnectionInformation conn = this.getInfo();
        JdbcDatabase db = new JdbcDatabase(conn);
        db.connect();

        int index = 243;
        String timeColumn = "pa__arrival_ts";
        String outFolder = "../../../host/";

        // find starting time
        String query = "SELECT COUNT(*) FROM " + conn.table;
        System.out.println("Getting size using " + query);
        ResultSet dbTable = db.getQueryData(query);
        ITable table = JdbcDatabase.getTable(dbTable);
        IColumn[] cols = table.getColumns(table.getSchema());
        assert cols.length == 1;
        assert table.getNumOfRows() == 1;
        long count = (long)cols[0].getDouble(0);

        query = "SELECT MIN(" + timeColumn + "), MAX(" + timeColumn + ") FROM " + conn.table;
        System.out.println("Getting time range using " + query);
        dbTable = db.getQueryData(query);
        table = JdbcDatabase.getTable(dbTable);
        cols = table.getColumns(table.getSchema());
        assert cols.length == 2;
        assert table.getNumOfRows() == 1;

        /*
        Instant start = Converters.checkNull(cols[0].getDate(0));
        Instant end = Converters.checkNull(cols[1].getDate(0));
        System.out.println("Time range is " + start + ":" + end + ", " + count + " rows");

        Instant lastTime = start.minusSeconds(1); // so we can use > below.
        */
        Instant lastTime = Instant.parse("2017-10-10T21:10:58.571Z");
        while (true) {
            query = "SELECT * FROM " + conn.table +
                    " WHERE " + timeColumn + " > " + sqlTime(lastTime) +
                    " ORDER BY " + timeColumn +
                    " LIMIT " + fragmentSize;

            System.out.println("Running query " + query);
            dbTable = db.getQueryData(query);
            table = JdbcDatabase.getTable(dbTable);
            System.out.println("Received table " + index + ", " + table.getNumOfRows() + " rows");
            String file = conn.table + index;
            if (index == 0)
                table.getSchema().writeToJsonFile(Paths.get(conn.table + ".schema"));
            CsvFileWriter fw = new CsvFileWriter(outFolder + file + ".csv");
            fw.setCompress(true);
            try {
                fw.writeTable(table);
            } catch (IOException e) {
                e.printStackTrace();
                break;
            }
            index++;

            if (table.getNumOfRows() == 0)
                break;
            ColumnAndConverter cc = table.getLoadedColumn(timeColumn);
            lastTime = cc.column.getDate(cc.column.sizeInRows() - 1);
        }
        db.disconnect();
    }

    // Downloads an impala table and splits it into pieces by time intervals
    // computed by a heuristic to avoid sorting.
    //@Test
    public void downloadSplitTableBalanced() throws SQLException {
        int fragmentSize = 300000;
        JdbcConnectionInformation conn = this.getInfo();
        JdbcDatabase db = new JdbcDatabase(conn);
        db.connect();

        String timeColumn = "pa__arrival_ts";
        String outFolder = "../../../host/";

        // find starting time
        String query = "SELECT COUNT(*) FROM " + conn.table;
        System.out.println("Getting size using " + query);
        ResultSet dbTable = db.getQueryData(query);
        ITable table = JdbcDatabase.getTable(dbTable);
        IColumn[] cols = table.getColumns(table.getSchema());
        assert cols.length == 1;
        assert table.getNumOfRows() == 1;
        long count = (long)cols[0].getDouble(0);
        int pieces = (int)(count / fragmentSize);
        if (pieces == 0)
            pieces = 1;

        query = "SELECT MIN(" + timeColumn + "), MAX(" + timeColumn + ") FROM " + conn.table;
        System.out.println("Getting time range using " + query);
        dbTable = db.getQueryData(query);
        table = JdbcDatabase.getTable(dbTable);
        cols = table.getColumns(table.getSchema());
        assert cols.length == 2;
        assert table.getNumOfRows() == 1;
        Instant start = Converters.checkNull(cols[0].getDate(0));
        //Instant end = Converters.checkNull(cols[1].getDate(0));
        Instant end = Instant.parse("2018-03-08T01:49:59.923Z");
        System.out.println("Time range is " + start + ":" + end + ", " + count + " rows");
        int fragmentsPerTable = 5;
        Duration span = Duration.between(start, end);
        Duration smallSpan = span.dividedBy(pieces * fragmentsPerTable);

        for (int index=316; index < pieces; index++) {
            query = "SELECT * FROM " + conn.table;
            String where = " WHERE ";
            for (int i=0; i < fragmentsPerTable; i ++) {
                int position = index + i * pieces;
                Instant from = start.plus(smallSpan.multipliedBy(position));
                Instant to = from.plus(smallSpan);
                if (i > 0)
                    where += " OR ";
                where += "(" + timeColumn + " >= " + sqlTime(from) +
                            " AND " + timeColumn + " < " + sqlTime(to) + ")";
            }

            query += where;
            System.out.println("Running query " + query);
            dbTable = db.getQueryData(query);
            table = JdbcDatabase.getTable(dbTable);
            System.out.println("Received table " + index + ", " + table.getNumOfRows() + " rows");
            String file = conn.table + index;
            CsvFileWriter fw = new CsvFileWriter(outFolder + file + ".csv");
            fw.setCompress(true);
            try {
                fw.writeTable(table);
            } catch (IOException e) {
                e.printStackTrace();
                break;
            }
        }
        db.disconnect();
    }